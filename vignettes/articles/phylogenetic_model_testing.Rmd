---
title: "Phylogenetic JSDM testing"
author: "Fiona Seaton"
date: "2022-10-04"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Problem:
Want to incorporate phylogenetic information into the JSDM. Initial thought was to add it to the species covariance matrix in the MGLMM model - alternatively could be added to the betas in a GLLVM (or MGLMM).

## Initial concept

JSDMs have

$$ y \sim g(\mu) $$

Where $y$ is a site (N) by species (S) matrix, $g()$ is a link function and $\mu$ is a N by S matrix.

$$ \mu = \alpha + \mathbf{X}*\mathbf{\beta} + u $$

Where $\alpha$ is the site specific intercept, $\mathbf{X}*\mathbf{\beta}$ is the environmental covariates (N by K (covars) matrix) multiplied by the species specific effects (K by S), and $u$ is the species covariance. In a MGLMM $u$ is a N by S matrix.

$$ u = ((diag(sigmas\_u) * L\_Rho\_species) * z\_species)' $$

In the MGLMM model the $u$ matrix is the transpose of the species-specific standard deviations ($sigmas\_u$, a S length vector) multiplied by the species correlation matrix ($L\_Rho\_species$) and then multipled against a standard normal S by N matrix ($z\_species$). This is how the mvtnorm package simulates a random multivariate normal FYI.

The original thinking was just to replace the $L\_Rho\_species$ matrix by some covariance matrix based on applying the Matern kernel to a phylogenetic distance matrix. Notes on how a Matern kernel works are elsewhere, but remember that there are two parameters of interest. First, $\eta^2$ which is the total variance that scales the entire matrix (ish) and second, $\rho$ which is the length scale parameter which determines how quickly the covariance decays with distance. Two obvious points of failure occurred initially. First, a covariance matrix is not a correlation matrix - I eventually concluded I should fix $\eta^2$ to 1 but still not sure if that was correct. Second, the phylogenetic trees were simulated with the ape package and the distances between species were generally between 1 to around 5 (depending on number of species, but ~1 was the minimum). The initial prior on $\rho$ was a tight prior around 1 which led to there being no phylogenetic signal to detect.

Stan code in package:
```{stan}
//Generated by jsdmstan
functions{
/**
* Create covariance function based on matern
* @param x A distance matrix
* @param sq_eta
* @param rho
* @param delta Nugget added to diagonal
* @param nu05 Indicates what form the function should take
*/
matrix cov_matern(matrix x, real sq_eta, real rho, real delta, int nu05){
    int N = dims(x)[1];
    matrix[N,N] K;
    for (i in 1:(N-1)) {
      K[i,i] = sq_eta + delta;
      for (j in (i + 1):N) {
        if(nu05 == 0){
          K[i, j] = sq_eta * exp(- x[i,j]/rho );
        } else if(nu05 == 1){
          real dist_rho;
          dist_rho = sqrt(3) * x[i,j]/rho;
          K[i, j] = sq_eta*(1 + dist_rho)*exp(- dist_rho);
        } else if(nu05 == 2){
          real dist_rho;
          dist_rho = sqrt(5) * x[i,j]/rho;
          K[i, j] = sq_eta*(1 + dist_rho + pow(dist_rho, 2) / 3)*exp(- dist_rho);
        } else if(nu05 == 3){
          real dist_rho;
          dist_rho = x[i,j]/rho;
          K[i, j] = sq_eta * exp(- pow(dist_rho, 2) / 2);
          } else {
          reject("nu05 must be an integer in range 0-3, given as:",nu05);
        }
        K[j, i] = K[i, j];
      }
    }
    K[N, N] = sq_eta + delta;
    return K;
  }

}
data{

  int<lower=1> N; // Number of samples
  int<lower=1> S; // Number of species

  int<lower=0> K; // Number of predictor variables
  matrix[N, K] X; // Predictor matrix

  int<lower=0,upper=1> site_intercept; // whether to include a site intercept
  int<lower=0>  Y[N,S]; //Species matrix
  matrix[S, S] Dmat; // Distance matrix between species
  int<lower=0,upper=3> nu05; // whether matern cov has nu = 1/2, 3/2 or 5/2
  real<lower=0> delta; // constant added to diagonal of covariance

}
transformed data{

}
parameters{

  // Site intercepts
  real a_bar[site_intercept];
  real<lower=0> sigma_a[site_intercept];
  vector[N] a[site_intercept];
  //betas are hierarchical with covariance model
  vector<lower=0>[K] sigmas_b;
  matrix[K, S] z_preds;
  // covariance matrix on betas by predictors
  cholesky_factor_corr[K] L_Rho_preds;
  // species covariances
  vector<lower=0>[S] sigmas_u;
  matrix[S, N] z_species;

  // kernel parameters
  real<lower=0> sq_eta;
  real<lower=0> rho;

}
transformed parameters{

  // covariance matrix on betas by preds
  matrix[K, S] betas;


  betas = diag_pre_multiply(sigmas_b, L_Rho_preds) * z_preds;

}
model{

  matrix[N,S] mu;
  matrix[N, S] u;
  u = (diag_pre_multiply(sigmas_u, cholesky_decompose(cov_matern(Dmat, sq_eta, rho, delta, nu05))) * z_species)';

  // model
  if(site_intercept == 1){
    matrix[N, S] alpha = rep_matrix(a_bar[1] + a[1,] * sigma_a[1], S);
    mu = alpha + (X * betas) + u;
  } else {
    mu = (X * betas) + u;
  }


  // Site-level intercept priors
  if(site_intercept == 1){
    a[1,] ~  normal(0,1) ;
    a_bar[1] ~  normal(0,1) ;
    sigma_a[1] ~  normal(0,1) ;
  }

  // Species parameter priors
  sigmas_b ~  normal(0,1) ;
  to_vector(z_preds) ~  normal(0,1) ;
  // covariance matrix priors
  L_Rho_preds ~  lkj_corr_cholesky(1) ;

  // Species parameter priors
  sigmas_u ~  normal(0,1) ;
  to_vector(z_species) ~  normal(0,1) ;

  //kernel parameters
  sq_eta ~  inv_gamma(10,.1) ;
  rho ~  inv_gamma(10,.1) ;


  for(i in 1:N) Y[i,] ~  poisson_log(mu[i,]);

}
generated quantities{
}

```

I ran the models many times and what happened a lot was that the $L\_Rho\_species$ matrix was resolved to the identity matrix all the time, and the $z\_species$ and $\beta$ parameters were wildly overestimated to compensate. I managed once I had figured out how to simulate data properly to occasionally get chains that would be around the correct $\rho$ value - however they would be 100% divergent transitions and limited to a very tight parameter space. Also there would still be some chains with $\rho$ being ~ 0, i.e. the $L\_rho\_species$ matrix would be an identity matrix. 

This resulted in a vast number of divergent transitions - and each chain occupying different parts of the parameter space e.g. one chain had $\rho$ at 4.6 +/- 0.02, and another 4.3 +/- 0.05. Examination of the pairs plot didn't make it clear which part of the parameterisation was failing - as multiple parameters had weird pathologies happening and I recognised none of them.
I then tried a bunch of different things. One of which was to set a really tight prior around $\rho$ to be at the simulated parameter value.

Stan code:

```{stan}
//Generated by jsdmstan
 functions{
/**
* Create covariance function based on matern
* @param x A distance matrix
* @param sq_eta
* @param rho
* @param delta Nugget added to diagonal
* @param nu05 Indicates what form the function should take
*/
matrix cov_matern(matrix x, real sq_eta, real rho, real delta, int nu05){
    int N = dims(x)[1];
    matrix[N,N] K;
    for (i in 1:(N-1)) {
      K[i,i] = sq_eta + delta;
      for (j in (i + 1):N) {
        if(nu05 == 0){
          K[i, j] = sq_eta * exp(- x[i,j]/rho );
        } else if(nu05 == 1){
          real dist_rho;
          dist_rho = sqrt(3) * x[i,j]/rho;
          K[i, j] = sq_eta*(1 + dist_rho)*exp(- dist_rho);
        } else if(nu05 == 2){
          real dist_rho;
          dist_rho = sqrt(5) * x[i,j]/rho;
          K[i, j] = sq_eta*(1 + dist_rho + pow(dist_rho, 2) / 3)*exp(- dist_rho);
        } else if(nu05 == 3){
          real dist_rho;
          dist_rho = x[i,j]/rho;
          K[i, j] = sq_eta * exp(- pow(dist_rho, 2) / 2);
          } else {
          reject("nu05 must be an integer in range 0-3, given as:",nu05);
        }
        K[j, i] = K[i, j];
      }
    }
    K[N, N] = sq_eta + delta;
    return K;
  }

}
data{

  int<lower=1> N; // Number of samples
  int<lower=1> S; // Number of species

  int<lower=0> K; // Number of predictor variables
  matrix[N, K] X; // Predictor matrix
  int<lower=0,upper=1> site_intercept; // whether to include a site intercept
  int<lower=0>  Y[N,S]; //Species matrix
  matrix[S, S] Dmat; // Distance matrix between species
  int<lower=0,upper=3> nu05; // whether matern cov has nu = 1/2, 3/2 or 5/2
  real<lower=0> delta; // constant added to diagonal of covariance

}
transformed data{

}
parameters{

  // Site intercepts
  real a_bar[site_intercept];
  real<lower=0> sigma_a[site_intercept];
  vector[N] a[site_intercept];
  //betas are hierarchical with covariance model
  vector<lower=0>[K] sigmas_b;
  matrix[K, S] z_preds;
  // covariance matrix on betas by predictors
  cholesky_factor_corr[K] L_Rho_preds;
  // species covariances
  vector<lower=0>[S] sigmas_u;
  matrix[S, N] z_species;

  // kernel parameters
  //real<lower=0> sq_eta;
  real<lower=0> rho;

}
transformed parameters{

  // covariance matrix on betas by preds
  matrix[K, S] betas;

  matrix[N, S] u;
  u = (diag_pre_multiply(sigmas_u, cholesky_decompose(cov_matern(Dmat, 1, rho, delta, nu05))) * z_species)';

  betas = diag_pre_multiply(sigmas_b, L_Rho_preds) * z_preds;

}
model{

  matrix[N,S] mu;

  // model
  if(site_intercept == 1){
    matrix[N, S] alpha = rep_matrix(a_bar[1] + a[1,] * sigma_a[1], S);
    mu = alpha + (X * betas) + u;
  } else {
    mu = (X * betas) + u;
  }


  // Site-level intercept priors
  if(site_intercept == 1){
    a[1,] ~  normal(0,1) ;
    a_bar[1] ~  normal(0,1) ;
    sigma_a[1] ~  normal(0,1) ;
  }
  // Species parameter priors
  sigmas_b ~  normal(0,1) ;
  to_vector(z_preds) ~  normal(0,1) ;
  // covariance matrix priors
  L_Rho_preds ~  lkj_corr_cholesky(1) ;

  // Species parameter priors
  sigmas_u ~  normal(0,1) ;
  to_vector(z_species) ~  normal(0,1) ;

  //kernel parameters
  //sq_eta ~  inv_gamma(10,.1) ;
  rho ~  normal(4.4,0.1) ;


  for(i in 1:N) Y[i,] ~  poisson_log(mu[i,]);

}
generated quantities{

}

```

This was run on the results of the `mglmm_sim_data` function.

```{r}
set.seed(789012)
phylo_dat <- mglmm_sim_data(N = 100, S = 40, K = 0, phylo = TRUE, covar = "matern_15",
                            family = "poisson", delta = 1e-5,
                            prior =  jsdm_prior(rho = "normal(4.4,0.1)"))
phylo_dat$pars$rho

# with really tight prior on rho
dat <- list(N = phylo_dat$N,
            S = phylo_dat$S,
            Y = phylo_dat$Y,
            K = 1,
            site_intercept = 0,
            X = data.frame("(Intercept)" = rep(1,100)),
            Dmat = phylo_dat$Dmat,
            nu05 = phylo_dat$nu05,
            delta = phylo_dat$delta)

library(rstan)
test_fit3 <- stan("~/Temp/mglmm_phylo_tightrho.stan",
                  data = dat, cores = 4)
pairs(test_fit3, pars = c("rho","sigmas_u[4]","betas[1,12]","sigmas_b[1]","z_species[5,3]"), log = TRUE)
test_res <- as.matrix(test_fit3)

```

```{r}
library(bayesplot)
mcmc_recover_hist(test_res[,c("rho","sigmas_b[1]")], true = c(phylo_dat$pars$rho,
                                                         phylo_dat$pars$beta_sds))
mcmc_recover_intervals(test_res[,grepl("sigmas_u", colnames(test_res))],
                       true = phylo_dat$pars$sigmas_u)

```


```{r}
set.seed(8901234)
phylo_dat <- mglmm_sim_data(N = 100, S = 40, K = 0, phylo = TRUE, covar = "matern_15",
                            family = "gaussian", delta = 1e-5,
                            prior =  jsdm_prior(rho = "inv_gamma(10,0.05)"))
phylo_dat$pars$rho

# with really tight prior on rho
test_fit <- stan_mglmm(X = NULL, Y = phylo_dat$Y, phylo = phylo_dat$Dmat,
                       delta = 1e-5, covar = "matern_15", family = "gaussian",
                       prior =  jsdm_prior(rho = "inv_gamma(10,0.05)"),
                       cores = 4)

```

```{r}
mcmc_plot(test_fit, plotfun="recover_hist", pars = c("rho","sigmas_b[1]"),
          true = c(phylo_dat$pars$rho,phylo_dat$pars$beta_sds))
mcmc_plot(test_fit, plotfun="recover_intervals", pars = "sigmas_u", regexp = TRUE,
          true = phylo_dat$pars$sigmas_u)
mcmc_plot(test_fit, plotfun="recover_intervals", pars = "betas", regexp = TRUE,
          true = c(phylo_dat$pars$betas))
mcmc_plot(test_fit, plotfun="recover_intervals", pars = "z_species\\[1,", regexp = TRUE,
          true = phylo_dat$pars$z_species[1,])


```

This worked but is not a viable solution for datasets where we don't know the $\rho$ value.

## Second idea

Second idea was to switch to how Gaussian Processes are parameterised. Here:

$$ u = L\_Rho\_species * sigmas\_u $$

Here $$u$$ is a S length vector, created by multiplying a S by S covariance matrix by a S length vector.

This didn't work either. All model fits resolved the covariance matrix to an identity matrix. 

I then considered the possibility that maybe I should be fitting this data to a Y vector (N*S length) rather than a N by S matrix.

Stan code:
```{stan}

functions{
matrix cov_matern(matrix x, real sq_eta, real rho, real delta, int nu05){
    int N = dims(x)[1];
    matrix[N,N] K;
    for (i in 1:(N-1)) {
      K[i,i] = sq_eta + delta;
      for (j in (i + 1):N) {
        if(nu05 == 0){
          K[i, j] = sq_eta * exp(- x[i,j]/rho );
        } else if(nu05 == 1){
          real dist_rho;
          dist_rho = (sqrt(3) * x[i,j])/rho;
          K[i, j] = sq_eta*(1 + dist_rho)*exp(- dist_rho);
        } else if(nu05 == 2){
          real dist_rho;
          dist_rho = (sqrt(5) * x[i,j])/rho;
          K[i, j] = sq_eta*(1 + dist_rho + pow(dist_rho, 2) / 3)*exp(- dist_rho);
        } else if(nu05 == 3){
          real dist_rho;
          dist_rho = x[i,j]/rho;
          K[i, j] = sq_eta * exp(- pow(dist_rho, 2) / 2);
          } else {
          reject("nu05 must be an integer in range 0-3, given as:",nu05);
        }
        K[j, i] = K[i, j];
      }
    }
    K[N, N] = sq_eta + delta;
    return K;
  }
}
data{
  int<lower=1> N; // Number of samples
  int<lower=1> S; // Number of species
  int<lower=0>  Y[N*S]; //Vector of Species matrix
  int<lower=0> Y_spid[N*S]; // Species ID
  int<lower=0> Y_stid[N*S]; // Site ID
  matrix[S, S] Dmat; // Distance matrix between species
  int<lower=0,upper=3> nu05; // whether matern cov has nu = 1/2, 3/2 or 5/2
  real<lower=0> delta; // constant added to diagonal of covariance

}
parameters{
  // species covariances
  vector<lower=0>[S] sigmas_u;
  // kernel parameters
  real<lower=0> sq_eta;
  real<lower=0> rho;
}
transformed parameters{

}
model{
  vector[N*S] mu;
  {
    matrix[S,S] u;
    vector[S] u_pred;

    u = cholesky_decompose(cov_matern(Dmat, sq_eta, rho, delta, nu05));
    u_pred = u * sigmas_u;

    for (i in 1:(N*S)){
      mu[i] = u_pred[Y_spid[i]];
    }
  }

  // Species parameter priors
  sigmas_u ~  normal(0,1) ;

  //kernel parameters
  sq_eta ~  inv_gamma(10,.1) ;
  rho ~  inv_gamma(10,.1) ;

  for(i in 1:(N*S)) Y[i] ~  poisson_log(mu[i]);

}

```

```{r}
set.seed(5)
N <- 400
S <- 11
phylo_dat <- mglmm_sim_data(N = N, S = S, K = 0, phylo = TRUE, covar = "matern_25",
                            family = "poisson", delta = 1e-10)

dat <- list(N = phylo_dat$N,
            S = phylo_dat$S,
            Y = c(phylo_dat$Y),
            Y_spid = rep(seq_len(phylo_dat$S), each = phylo_dat$N),
            Y_stid = rep(seq_len(phylo_dat$N), phylo_dat$S),
            Dmat = phylo_dat$Dmat,
            nu05 = phylo_dat$nu05,
            delta = phylo_dat$delta)

test_fit3 <- stan("~/Temp/mglmm_phylo_test_v4.stan",
                  data = dat)
```


This did not help. I also played around with increasing the size of S and N. S went up to 40, and N up to 500.

It then occurred to me that I wasn't sure if simulating data according to the models actually resulted in the data showing correlation between species that declined with increasing phylogenetic distance. So I started simulating data according to these models (with no $\alpha + \mathbf{X}*\beta$ component, just the $u$).

Simulation code for second parameterisation:
```{r}
# set.seed(3543357)
test_cor <- replicate(100, {
  S <- 15
  N <- 200
  Dmat <- stats::cophenetic(ape::rtree(S))
  sq_eta <- rinvgamma(1,10,.1)
  rho <- runif(1,1.5,4)

  L_Rho_species <- cov_matern(Dmat,
                              sq_eta = sq_eta, rho = rho, delta = 1e-10,
                              nu05 = "1")

  sigmas_u <- abs(rnorm(S,0,1))

  u_ij <- L_Rho_species %*% sigmas_u

  Y <- matrix(NA, nrow = N, ncol = S)

  sigma <- abs(rnorm(1, sd = 0.2))

  for (i in 1:N){
    for (j in 1:S){
      Y[i,j] <- stats::rnorm(1,u_ij[j],sigma)
    }
  }

  diag(Dmat) <- NA
  cor_Y <- cor(Y)
  diag(cor_Y) <- NA
  Dmat <- Dmat[upper.tri(Dmat)]
  cor_Y <- cor_Y[upper.tri(cor_Y)]
  cor(c(Dmat),c(cor_Y), use = "complete.obs")
})
hist(test_cor)

```

Simulation code for the first parametrisation:
```{r}
set.seed(5)
test_cor <- replicate(1000, {
  S <- 50
  N <- 200
  Dmat <- stats::cophenetic(ape::rtree(S))
  sq_eta <- rinvgamma(1,10,.1)
  rho <- runif(1,2,5)

  L_Rho_species <- t(chol(cov_matern(Dmat,
                                     sq_eta = 1, rho = rho, delta = 1e-5,
                                     nu05 = "1"
  )))

  # L_Rho_species <- t(chol(1/(1+Dmat)))
  # L_Rho_species <- 1/(1+Dmat)

  sigmas_u <- abs(rnorm(S))

  u_ij <- matrix(rnorm(N*S),nrow=N) %*% (diag(sigmas_u) * L_Rho_species)


  # u_ij <- t((diag(sigmas_u) * L_Rho_species) %*% matrix(rnorm(N*S),nrow=S) )

  Y <- matrix(NA, nrow = N, ncol = S)

  for (i in 1:N){
    for (j in 1:S){
      Y[i,j] <- stats::rpois(1,exp(u_ij[i,j]))
    }
  }

  diag(Dmat) <- NA
  cor_Y <- cor(Y)
  diag(cor_Y) <- NA
  # return(c(cor(c(Dmat),c(cor(Y)), use = "complete.obs"),
  #          rho))

  Dmat <- Dmat[upper.tri(Dmat)]
  cor_Y <- cor_Y[upper.tri(cor_Y)]
  cor(c(Dmat),c(cor_Y), use = "complete.obs")
})

hist(test_cor)
```

So, neither of these models seem to lead to correlations between species that are related to phylogenetic distance between species.

Annoyingly I definitely managed to edit the second parametrisation simulation code so it worked, but cannot figure out how right now.


## Third idea

I then looked at the Hmsc paper to figure out how they incorporated phylogenetic data into their model. They put the phylogenetic covariance onto the $\beta$ (they use a GLLVM model so the $u$ bit is different and would be more complicated to put phylo info on). Their 2017 paper main text, 2017 paper supplementary materials and vignette that includes simulating according to phylo data (the high dimensional vignette) all are contradictory.

Main text:

$$ \beta_{..} \sim N(\mu_{..}, \mathbf{V} \otimes [\rho \mathbf{C} + (1 - \rho) \mathbf{I}]) $$

Where the dot indicates a specific species x site combination.

Supplementary Information:

$$ \beta_{j.} = \mu_{j.} + a_j $$

Where
$$ a \sim N(0, \mathbf{V} \otimes [\rho \mathbf{C} + (1 - \rho) \mathbf{I}]) $$

and 
$$ \mu_j = \gamma \mathbf{T_j} $$

Where the $\mu$ bit represents the influence of traits and the $a$ bit the influence of phylogeny. There is no way to make either of these work as $\beta$ must by a S by K matrix (or a K by S matrix) and the Kronecker product ($\otimes$) on $\mathbf{V}$ (a K by K matrix according to their 2011 paper) and $\mathbf{C}$ (an S by S matrix) gives a K\*S by K\*S matrix. This cannot be turned into a matrix of suitable size.

The vignette applies the phylogenetic correlation (from a Brownian motion model applied to a randomly generated tree) to the generation of trait values for each species, generating a S by ntrait matrix. This is then somehow turned into a S by K matrix through a series of subsetting exercises.

## Fourth idea (from Pete)

Could turn $sigmas_u$ into depending on phylogeny - which would correspond to the variance of each species being phylogenetically related. Probably possible, not particularly ecologically interesting.

# Ecological thoughts

Where you put the phylogenetic information corresponds to different ecological theories. On the $\beta$ makes sense for many species (corresponding to related species having similar traits), while on the covariance matrix ($u$) directly might make sense in fewer contexts (dispersal limited, say - related species are close to each other).

