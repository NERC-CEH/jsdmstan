<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><title>Make stancode for the jsdm model — jsdm_stancode • jsdmstan</title><script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet"><script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/Montserrat-0.4.9/font.css" rel="stylesheet"><link href="../deps/Roboto_Mono-0.4.9/font.css" rel="stylesheet"><link href="../deps/font-awesome-6.4.2/css/all.min.css" rel="stylesheet"><link href="../deps/font-awesome-6.4.2/css/v4-shims.min.css" rel="stylesheet"><script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Make stancode for the jsdm model — jsdm_stancode"><meta name="description" content="This function returns the Stan code used to fit the model as specified by the data
list, family and method."><meta property="og:description" content="This function returns the Stan code used to fit the model as specified by the data
list, family and method."></head><body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">jsdmstan</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.4.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto"><li class="active nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles"><li><a class="dropdown-item" href="../articles/jsdmstan-overview.html">Overview</a></li>
  </ul></li>
      </ul><ul class="navbar-nav"><li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json"></form></li>
      </ul></div>


  </div>
</nav><div class="container template-reference-topic">
<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Make stancode for the jsdm model</h1>

      <div class="d-none name"><code>jsdm_stancode.Rd</code></div>
    </div>

    <div class="ref-description section level2">
    <p>This function returns the Stan code used to fit the model as specified by the data
list, family and method.</p>
    </div>

    <div class="section level2">
    <h2 id="ref-usage">Usage<a class="anchor" aria-label="anchor" href="#ref-usage"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">jsdm_stancode</span><span class="op">(</span></span>
<span>  <span class="va">method</span>,</span>
<span>  <span class="va">family</span>,</span>
<span>  prior <span class="op">=</span> <span class="fu"><a href="jsdm_prior.html">jsdm_prior</a></span><span class="op">(</span><span class="op">)</span>,</span>
<span>  log_lik <span class="op">=</span> <span class="cn">TRUE</span>,</span>
<span>  site_intercept <span class="op">=</span> <span class="st">"none"</span>,</span>
<span>  beta_param <span class="op">=</span> <span class="st">"cor"</span>,</span>
<span>  zi_param <span class="op">=</span> <span class="st">"constant"</span></span>
<span><span class="op">)</span></span>
<span></span>
<span><span class="co"># S3 method for class 'jsdmstan_model'</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/print.html" class="external-link">print</a></span><span class="op">(</span><span class="va">x</span>, <span class="va">...</span><span class="op">)</span></span></code></pre></div>
    </div>

    <div class="section level2">
    <h2 id="arguments">Arguments<a class="anchor" aria-label="anchor" href="#arguments"></a></h2>


<dl><dt id="arg-method">method<a class="anchor" aria-label="anchor" href="#arg-method"></a></dt>
<dd><p>The method, one of <code>"gllvm"</code> or <code>"mglmm"</code></p></dd>


<dt id="arg-family">family<a class="anchor" aria-label="anchor" href="#arg-family"></a></dt>
<dd><p>is the response family, must be one of <code>"gaussian"</code>,
<code>"neg_binomial"</code>, <code>"poisson"</code>, <code>"binomial"</code>,
<code>"bernoulli"</code>, <code>"zi_poisson"</code>, or
<code>"zi_neg_binomial"</code>. Regular expression
matching is supported.</p></dd>


<dt id="arg-prior">prior<a class="anchor" aria-label="anchor" href="#arg-prior"></a></dt>
<dd><p>The prior, given as the result of a call to <code><a href="jsdm_prior.html">jsdm_prior()</a></code></p></dd>


<dt id="arg-log-lik">log_lik<a class="anchor" aria-label="anchor" href="#arg-log-lik"></a></dt>
<dd><p>Whether the log likelihood should be calculated in the generated
quantities (by default <code>TRUE</code>), required for loo</p></dd>


<dt id="arg-site-intercept">site_intercept<a class="anchor" aria-label="anchor" href="#arg-site-intercept"></a></dt>
<dd><p>Whether a site intercept should be included, potential
values <code>"none"</code> (no site intercept), <code>"grouped"</code> (a site intercept
with hierarchical grouping) or <code>"ungrouped"</code> (site intercept with no
grouping)</p></dd>


<dt id="arg-beta-param">beta_param<a class="anchor" aria-label="anchor" href="#arg-beta-param"></a></dt>
<dd><p>The parameterisation of the environmental covariate effects, by
default <code>"cor"</code>. See details for further information.</p></dd>


<dt id="arg-zi-param">zi_param<a class="anchor" aria-label="anchor" href="#arg-zi-param"></a></dt>
<dd><p>For the zero-inflated families, whether the zero-inflation parameter
is a species-specific constant (default, <code>"constant"</code>), or varies by
environmental covariates (<code>"covariate"</code>).</p></dd>


<dt id="arg-x">x<a class="anchor" aria-label="anchor" href="#arg-x"></a></dt>
<dd><p>The jsdm_stancode object</p></dd>


<dt id="arg--">...<a class="anchor" aria-label="anchor" href="#arg--"></a></dt>
<dd><p>Currently unused</p></dd>

</dl></div>
    <div class="section level2">
    <h2 id="value">Value<a class="anchor" aria-label="anchor" href="#value"></a></h2>
    <p>A character vector of Stan code, class "jsdmstan_model"</p>
    </div>
    <div class="section level2">
    <h2 id="details">Details<a class="anchor" aria-label="anchor" href="#details"></a></h2>
    <p>Environmental covariate effects (<code>"betas"</code>) can be parameterised in two
ways. With the <code>"cor"</code> parameterisation all covariate effects are assumed
to be constrained by a correlation matrix between the covariates. With the
<code>"unstruct"</code> parameterisation all covariate effects are assumed to draw
from a simple distribution with no correlation structure. Both parameterisations
can be modified using the prior object.</p>
    </div>
    <div class="section level2">
    <h2 id="functions">Functions<a class="anchor" aria-label="anchor" href="#functions"></a></h2>

<ul><li><p><code>print(jsdmstan_model)</code>: A printing function for jsdmstan_model objects</p></li>
</ul></div>

    <div class="section level2">
    <h2 id="ref-examples">Examples<a class="anchor" aria-label="anchor" href="#ref-examples"></a></h2>
    <div class="sourceCode"><pre class="sourceCode r"><code><span class="r-in"><span><span class="fu">jsdm_stancode</span><span class="op">(</span>family <span class="op">=</span> <span class="st">"gaussian"</span>, method <span class="op">=</span> <span class="st">"gllvm"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> //Generated by jsdmstan</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  functions{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N; // Number of sites</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; S; // Number of species</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; D; // Number of latent dimensions </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; K; // Number of predictor variables</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, K] X; // Predictor matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real Y[N,S]; //Species matrix    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed data{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Ensures identifiability of the model - no rotation of factors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; M;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   M = D * (S - D) + choose(D, 2) + D;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   //betas are hierarchical with covariance model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[K] sigmas_preds;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[K, S] z_preds;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // covariance matrix on betas by predictors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   corr_matrix[K] cor_preds; </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Factor parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector[M] L; // Non-zero factor loadings</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; sigma_L; // variance of species loadings</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Latent variables</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[D, N] LV_uncor; // Per-site latent variable </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   real&lt;lower=0&gt; sigma[S]; // Gaussian parameters </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // covariance matrix on betas by preds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[K, S] betas;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Construct factor loading matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[S, D] Lambda_uncor;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Constraints to allow identifiability of loadings</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for (i in 1:(D-1)) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (j in (i+1):(D)){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       Lambda_uncor[i,j] = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     int index;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     index = 0;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     for (j in 1:D) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for (i in j:S) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         index = index + 1;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>         Lambda_uncor[i, j] = L[index];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   betas = diag_pre_multiply(sigmas_preds, cor_preds) * z_preds;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N,S] mu;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, S] LV_sum = ((Lambda_uncor * sigma_L) * LV_uncor)';</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu = (X * betas) + LV_sum;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Species parameter priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigmas_preds ~  normal(0,1) ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   to_vector(z_preds) ~  normal(0,1) ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // covariance matrix priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   cor_preds ~  lkj_corr(1) ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Factor priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   to_vector(LV_uncor) ~  normal(0,1) ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   L ~  normal(0,1) ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma_L ~  normal(0,1) ; // Variance of factor loadings</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   //Standard deviation parameters</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigma ~  normal(0,1) ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for(i in 1:N) Y[i,] ~  normal(mu[i,], sigma); </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Calculate linear predictor, y_rep, log likelihoods for LOO</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, S] log_lik;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Sign correct factor loadings and factors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[D, N] LV;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[S, D] Lambda;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for(d in 1:D){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     if(Lambda_uncor[d,d] &lt; 0){</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       Lambda[,d] = -1 * Lambda_uncor[,d];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       LV[d,] = -1 * LV_uncor[d,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     } else {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       Lambda[,d] = Lambda_uncor[,d];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       LV[d,] = LV_uncor[d,];</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   } </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     matrix[N, S] linpred;  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     linpred = (X * betas) + ((Lambda_uncor * sigma_L) * LV_uncor)' ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for(i in 1:N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for(j in 1:S) { log_lik[i, j] = normal_lpdf(Y[i, j] | linpred[i, j], sigma[j]); </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span><span class="fu">jsdm_stancode</span><span class="op">(</span>family <span class="op">=</span> <span class="st">"poisson"</span>, method <span class="op">=</span> <span class="st">"mglmm"</span><span class="op">)</span></span></span>
<span class="r-out co"><span class="r-pr">#&gt;</span> //Generated by jsdmstan</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  functions{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> data{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; N; // Number of sites</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=1&gt; S; // Number of species</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; K; // Number of predictor variables</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, K] X; // Predictor matrix</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   int&lt;lower=0&gt; Y[N,S]; //Species matrix    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed data{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> parameters{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   //betas are hierarchical with covariance model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[K] sigmas_preds;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[K, S] z_preds;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // covariance matrix on betas by predictors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   corr_matrix[K] cor_preds; </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // species covariances</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   vector&lt;lower=0&gt;[S] sigmas_species;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[S, N] z_species;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   corr_matrix[S] cor_species;  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> transformed parameters{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // covariance matrix on betas by preds</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[K, S] betas;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, S] u;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   u = (diag_pre_multiply(sigmas_species, cor_species) * z_species)';</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   betas = diag_pre_multiply(sigmas_preds, cor_preds) * z_preds;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> model{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N,S] mu;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // model</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   mu = (X * betas) + u;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Species parameter priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigmas_preds ~  normal(0,1) ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   to_vector(z_preds) ~  normal(0,1) ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // covariance matrix priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   cor_preds ~  lkj_corr(1) ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Species parameter priors</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   sigmas_species ~  normal(0,1) ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   to_vector(z_species) ~  normal(0,1) ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   cor_species ~  lkj_corr(1) ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   for(i in 1:N) Y[i,] ~  poisson_log(mu[i,]); </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> generated quantities{</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   // Calculate linear predictor, y_rep, log likelihoods for LOO</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   matrix[N, S] log_lik;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     matrix[N, S] linpred;  </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     linpred = (X * betas) + u ;</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>      </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for(i in 1:N) {</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       for(j in 1:S) { log_lik[i, j] = poisson_log_lpmf(Y[i, j] | linpred[i, j]); </span>
<span class="r-out co"><span class="r-pr">#&gt;</span>       }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>     }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>   }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span>    </span>
<span class="r-out co"><span class="r-pr">#&gt;</span> }</span>
<span class="r-out co"><span class="r-pr">#&gt;</span> </span>
<span class="r-in"><span></span></span>
</code></pre></div>
    </div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside></div>


    <footer><div class="pkgdown-footer-left">
  <p>Developed by Fiona Seaton.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer></div>





  </body></html>

